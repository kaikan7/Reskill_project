/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include <stdio.h>

/*Define PORT10 Registers for LED*/
#define PORT10_BASE     (0xF003B000)
#define PORT10_IOCR0    (*(volatile unsigned int*)(PORT10_BASE + 0x10)) //RGB LED도 동일
#define PORT10_OMR      (*(volatile unsigned int*)(PORT10_BASE + 0x04)) //RGB LED도 동일

/* Define PORT02 Registers for Switch2 */
#define PORT02_BASE     (0xF003A200)
#define PORT02_IOCR0    (*(volatile unsigned int*)(PORT02_BASE + 0x10))
#define PORT02_IN       (*(volatile unsigned int*)(PORT02_BASE + 0x24))

// Define PORT02/10 Registers for RGB LED
#define PORT02_IOCR4    (*(volatile unsigned int*)(PORT02_BASE + 0x14))
#define PORT02_OMR      (*(volatile unsigned int*)(PORT02_BASE + 0x04))
#define PORT10_IOCR4    (*(volatile unsigned int*)(PORT10_BASE + 0x14))

/* Port I/O Control Register Set */
#define PC1             11  //Red LED - P10.IOCR0.PC1
                            //switch D3 - P02_1,  P02_IOCR0.PC1
#define PC2             19  //Blue LED - P10.IOCR0.PC2
#define PC0             3   //switch1 D2 Pin - P02_00,  P02_IOCR0.PC0

/* Port Data Register Set */
#define PCL1            17
#define PS1             1
#define PCL2            18
#define PS2             2

//RGB LED
#define PC7             27
#define PCL7            23
#define PS7             7
#define PC5             11
#define PC3             27
#define PCL5            21
#define PCL3            19
#define PS5             5
#define PS3             3

#define P1              1   //switch2 D3 Pin - P02_1,  P02_IOCR0.PC1
#define P0              0   //switch1 D2 Pin - P02_00,  P02_IOCR0.PC0

// SCU Registers (인터럽트 인풋 채널, Safety 설정 레지스터)
#define SCU_BASE        (0xF0036000)
#define SCU_WDTSCON0    (*(volatile unsigned int*)(SCU_BASE + 0x0F0))//for switch interrupt
#define SCU_EICR1       (*(volatile unsigned int*)(SCU_BASE + 0x214))
#define SCU_IGCR0       (*(volatile unsigned int*)(SCU_BASE + 0x22C)) //설정 가능한 output channel 2개 있음(0~1번)

#define SCU_WDT_CPU0CON0    (*(volatile unsigned int*)(SCU_BASE + 0x100))//for timer interrupt, ADC도 포함


#define LCK             1
#define ENDINIT         0
#define INP0            12
#define EIEN0           11
#define FEN0            8
#define EXIS0           4
#define IGP0            14  //output channel 0에 대한 설정 비트임
#define IGP1            30  //output channel 1에 대한 설정 비트임 (csj 추가)

// SRC Registers (인터럽트 라우터 설정 레지스터)
#define SRC_BASE        (0xF0038000)
#define SRC_SCUERU0     (*(volatile unsigned int*)(SRC_BASE + 0xCD4))//for switch interrupt router 0
#define SRC_SCUERU1     (*(volatile unsigned int*)(SRC_BASE + 0xCD8))//for switch interrupt touter 1

#define SRC_CCU60_SR0     (*(volatile unsigned int*)(SRC_BASE + 0x420))//for timer interrupt

#define TOS             11
#define SRE             10
#define SRPN            0

// CCU60 Registers
#define CCU60_BASE      (0xF0002A00)
#define CCU60_CLC       (*(volatile unsigned int*)(CCU60_BASE + 0x00))
#define CCU60_T12       (*(volatile unsigned int*)(CCU60_BASE + 0x20))
#define CCU60_T12PR     (*(volatile unsigned int*)(CCU60_BASE + 0x24))
#define CCU60_TCTR0     (*(volatile unsigned int*)(CCU60_BASE + 0x70))
#define CCU60_TCTR4     (*(volatile unsigned int*)(CCU60_BASE + 0x78))
#define CCU60_INP       (*(volatile unsigned int*)(CCU60_BASE + 0xAC))
#define CCU60_IEN       (*(volatile unsigned int*)(CCU60_BASE + 0xB0))

// VADC Registers
#define VADC_BASE       (0xF0020000)
#define VADC_CLC        (*(volatile unsigned int*)(VADC_BASE + 0x000))
#define VADC_GLOBCFG    (*(volatile unsigned int*)(VADC_BASE + 0x080))
#define VADC_G4ARBCFG   (*(volatile unsigned int*)(VADC_BASE + 0x1480))
#define VADC_G4ARBPR    (*(volatile unsigned int*)(VADC_BASE + 0x1484))
#define VADC_G4ICLASS0  (*(volatile unsigned int*)(VADC_BASE + 0x14A0))
#define VADC_G4QMR0     (*(volatile unsigned int*)(VADC_BASE + 0x1504))
#define VADC_G4QINR0    (*(volatile unsigned int*)(VADC_BASE + 0x1510))
#define VADC_G4CHCTR7   (*(volatile unsigned int*)(VADC_BASE + 0x161C))
#define VADC_G4RES1     (*(volatile unsigned int*)(VADC_BASE + 0x1704))


#define DISS            1
#define DISR            0
#define CTM             7
#define T12PRE          3
#define T12CLK          0
#define T12STR          6
#define T12RS           1   // bitfield for Timer T12 Run Set
#define T12RR           0   // bitfield for Timer T12 Run Reset
#define INPT12          10
#define ENT12PM         7

#define ANONC           0
#define ASEN0           24
#define CSM0            3
#define PRIO0           0
#define CMS             8
#define STCS            0
#define FLUSH           10
#define TREV            9
#define ENGT            0
#define RF              5
#define REQCHNR         0
#define RESPOS          21
#define RESREG          16
#define ICLSEL          0
#define VF              31
#define RESULT          0

// GTM Registers
// GTM - CMU
#define GTM_BASE            (0xF0100000)
#define GTM_CMU_CLK_EN      (*(volatile unsigned int*)(GTM_BASE + 0x00300))
#define GTM_CMU_FXCLK_CTRL  (*(volatile unsigned int*)(GTM_BASE + 0x00344))

#define EN_FXCLK            22
#define FXCLK_SEL           0

// GTM - TOM0
#define GTM_TOM0_TGC0_GLB_CTRL        (*(volatile unsigned int*)(GTM_BASE + 0x08030))
#define GTM_TOM0_TGC0_ENDIS_CTRL      (*(volatile unsigned int*)(GTM_BASE + 0x08070))
#define GTM_TOM0_TGC0_OUTEN_CTRL      (*(volatile unsigned int*)(GTM_BASE + 0x08078))
#define GTM_TOM0_TGC0_FUPD_CTRL       (*(volatile unsigned int*)(GTM_BASE + 0x08038))
#define GTM_TOM0_CH1_CTRL             (*(volatile unsigned int*)(GTM_BASE + 0x08040))
#define GTM_TOM0_CH1_SR0              (*(volatile unsigned int*)(GTM_BASE + 0x08044))
#define GTM_TOM0_CH1_SR1              (*(volatile unsigned int*)(GTM_BASE + 0x08048))
#define GTM_TOM0_CH2_CTRL             (*(volatile unsigned int*)(GTM_BASE + 0x08080))
#define GTM_TOM0_CH2_SR0              (*(volatile unsigned int*)(GTM_BASE + 0x08084))
#define GTM_TOM0_CH2_SR1              (*(volatile unsigned int*)(GTM_BASE + 0x08088))

/* for BUZZER */
#define GTM_TOM0_TGC1_GLB_CTRL        (*(volatile unsigned int*)(GTM_BASE + 0x08230))
#define GTM_TOM0_TGC1_ENDIS_CTRL      (*(volatile unsigned int*)(GTM_BASE + 0x08270))
#define GTM_TOM0_TGC1_OUTEN_CTRL      (*(volatile unsigned int*)(GTM_BASE + 0x08278))
#define GTM_TOM0_TGC1_FUPD_CTRL       (*(volatile unsigned int*)(GTM_BASE + 0x08238))
#define GTM_TOM0_CH11_CTRL            (*(volatile unsigned int*)(GTM_BASE + 0x082C0))
#define GTM_TOM0_CH11_SR0             (*(volatile unsigned int*)(GTM_BASE + 0x082C4))
#define GTM_TOM0_CH11_SR1             (*(volatile unsigned int*)(GTM_BASE + 0x082C8))


#define UPEN_CTRL1          18
#define UPEN_CTRL2          20
#define UPEN_CTRL3          22
#define HOST_TRIG           0
#define ENDIS_CTRL1         2
#define ENDIS_CTRL2         4
#define ENDIS_CTRL3         6
#define OUTEN_CTRL1         2
#define OUTEN_CTRL2         4
#define OUTEN_CTRL3         6
#define RSTCN0_CH1          18
#define RSTCN0_CH2          20
#define RSTCN0_CH3          22
#define FUPD_CTRL1          2
#define FUPD_CTRL2          4
#define FUPD_CTRL3          6
#define CLK_SRC_SR          12
#define SL                  11

// GTM
#define GTM_CLC                       (*(volatile unsigned int*)(GTM_BASE + 0x9FD00))
#define GTM_TOUTSEL6                  (*(volatile unsigned int*)(GTM_BASE + 0x9FD48))
#define GTM_TOUTSEL0                  (*(volatile unsigned int*)(GTM_BASE + 0x9FD30))

#define DISS                1
#define DISR                0
#define SEL3                6
#define SEL7                14
#define SEL8                16


void init_RGBLED(void);
void init_VADC(void);
void VADC_startConversion(void);
unsigned int VADC_readResult(void);
void init_GTM_TOM0_PWM(void);

// LED를 GPIO로 사용할 때 초기화 함수(시작)
/*Led 초기화(Red, Blue) */
//void init_LED(void) {
//
//    /* Reset PC1 & PC2 in IOCR0 */
//    PORT10_IOCR0 &= ~((0x1F) << PC1);
//    PORT10_IOCR0 &= ~((0x1F) << PC2);
//
//    /* Set PC1 & PC2 with push-pull(2b10000) */
//    PORT10_IOCR0 |= ((0x10) << PC1);
//    PORT10_IOCR0 |= ((0x10) << PC2);
//}
// LED를 GPIO로 사용할 때 초기화 함수(끝)

// LED를 GTM으로 사용할 때 초기화 함수(시작)
void init_LED(void)
{
    PORT10_IOCR0 &= ~((0x1F) << PC1);       //PORT10.1 : Alternate output function 1(push-pull)
    PORT10_IOCR0 |= ((0x11) << PC1);        //PORT10.1 : GTM_TOUT103

    PORT10_IOCR0 &= ~((0x1F) << PC2);       //PORT10.2 : Alternate output function 1(push-pull)
    PORT10_IOCR0 |= ((0x11) << PC2);        //PORT10.2 : GTM_TOUT104

}
// LED를 GTM으로 사용할 때 초기화 함수(끝)

/* Switch 2 초기화 */
void init_Switch(void) {

    /*Reset PC1 in IOCR0 --- switch 2*/
    PORT02_IOCR0 &= ~((0x1F) << PC1);

    /* Set PC1 with push-pull(2b0xx10) */
    PORT02_IOCR0 |= ((0x2) << PC1);

    /*Reset PC0 in IOCR0 --- switch 1*/
    PORT02_IOCR0 &= ~((0x1F) << PC0);

    /* Set PC0 with push-pull(2b0xx10) */
    PORT02_IOCR0 |= ((0x2) << PC0);
}

void init_RGBLED(void)
{
    // Reset IOCR0 bits
    PORT02_IOCR4 &= ~((0x1F) << PC7);
    PORT10_IOCR4 &= ~((0x1F) << PC5);
    PORT10_IOCR0 &= ~((0x1F) << PC3);

    // Set PC bits in IOCR0 with push-pull(2b1000)
    PORT02_IOCR4 |= ((0x10) << PC7);
    PORT10_IOCR4 |= ((0x10) << PC5);
    PORT10_IOCR0 |= ((0x10) << PC3);

}

void init_Buzzer(void)
{
    PORT02_IOCR0 &= ~((0x1F) << PC3);           // PORT02.3 : Alternate output function 1 (push-pull)
    PORT02_IOCR0 |= ((0x11) << PC3);            // PORT02.3 : GTM_TOUT3
}
// Switch Interrupt Safty clear, set하는 함수 정리
// -------------------------------------------------------------------------------------
void unprotect_Safety(void)
{
    // Password Access to unlock WDTSCON0
    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDTSCON0 & (1 << LCK)) != 0);

    // Modify Access to clear ENDINIT bit
    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) | (1 << LCK)) & ~(1 << ENDINIT);
    while((SCU_WDTSCON0 & (1 << LCK)) == 0);
}

void protect_Safety(void)
{
    // Password Access to unlock WDTSCON0
    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDTSCON0 & (1 << LCK)) != 0);

    // Modify Access to set ENDINIT bit
    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDTSCON0 & (1 << LCK)) == 0);
}
//------------------------------------------------------------------------------------

// Timer Interrupt Safty clear, set하는 함수 정리
// -------------------------------------------------------------------------------------
void initaccess_tiSystem(void)
{
    /* Password Access to unlock WDTSCON0 */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) != 0);

    /* Modify Access to clear ENDINIT bit */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) | (1 << LCK)) & ~(1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) == 0);

}

void finishaccess_tiSystem(void)
{
    /* Password Access to unlock WDTSCON0 */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) != 0);

    /* Modify Access to clear ENDINIT bit */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) == 0);

}

// -------------------------------------------------------------------------------------

/* Initialize External Request Unit (ERU) */
void init_ERU(void)
{
    // ERU Input Channel 2 setting

    unprotect_Safety();
//    // Password Access to unlock WDTSCON0
//    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
//    while((SCU_WDTSCON0 & (1 << LCK)) != 0);
//
//    // Modify Access to clear ENDINIT bit
//    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) | (1 << LCK)) & ~(1 << ENDINIT);
//    while((SCU_WDTSCON0 & (1 << LCK)) == 0);

    SCU_EICR1 &= ~((0x7) << EXIS0);             // External input 1 is selected
    SCU_EICR1 |= ((0x1) << EXIS0);

    SCU_EICR1 |= (1 << FEN0);                   // Falling edge enable (switch on 시 5V --> 0V가 됨. 이 상태 변화시 인터럽트 발생한다 뜻)

    SCU_EICR1 |= ((0x1) << EIEN0);              // The trigger event is enabled

    //SCU_EICR1 &= ~((0x7) << INP0);              // Bit Clear, Set 0x0....An event form input ETL 2 triggers output OGU0

    SCU_EICR1 &= ~((0x7) << INP0);              // Bit Clear...An event form input ETL 2 triggers output OGU1
    SCU_EICR1 |= ((0x1) << INP0);               // Bit Set...An event form input ETL 2 triggers output OGU1

//    SCU_EICR1 |= ((0x1) << INP0);

//    SCU_IGCR0 &= ~((0x3) << IGP0);              // IOUT(0) is activated in response to a trigger event
//    SCU_IGCR0 |= ((0x1) << IGP0);               // The pattern is not considered
    SCU_IGCR0 &= ~((0x3) << IGP1);              // csj 추가...IOUT(1) is activated in response to a trigger event
    SCU_IGCR0 |= ((0x1) << IGP1);               // csj 추가...The pattern is not considered

//    // Password Access to unlock WDTSCON0
//    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
//    while((SCU_WDTSCON0 & (1 << LCK)) != 0);
//
//    // Modify Access to set ENDINIT bit
//    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
//    while((SCU_WDTSCON0 & (1 << LCK)) == 0);

    protect_Safety();


    //-------------------SRC Interrupt Router 번호 선택 테스트(Start)-------------------------------------------------
    //Input Channel 2 선택 --> Output Channel 연결 필요 --> Interrupt Router 연결하고 Interrupt 동작할 CPU 선택
    //이때 Output Channel은 0~7번까지 선택가능함
    //이때 Interrupt Router는 Output Channel번호와 매핑 되어 있음
    //즉, Output Channel 0 -- Interrupt Router 0, Output Channel 1 -- Interrupt Router 1
    //Output Channel 1 -- Interrupt Router 1 선택하면 기존 설정한 Interrupt Router 0은 주석처리 안 해도 된다.
    //이유는 Interrupt Router 0으로 연결된 Output Channel 0을 비활성화 했기 때문에 Router로 들어오는 입력은 없다.


    /* SRC Interrupt Router0 Setting For ECU */
    SRC_SCUERU0 &= ~((0xFF) << SRPN);           // Set Priority : 0x0A
    SRC_SCUERU0 |= ((0x0A) << SRPN);

    SRC_SCUERU0 &= ~((0x3) << TOS);             // CPU0 services

    SRC_SCUERU0 |= (1 << SRE);                  // Service Request is enabled

    /* SRC Interrupt Router1 Setting For ECU */
    SRC_SCUERU1 &= ~((0xFF) << SRPN);           // Set Priority : 0x0A
    SRC_SCUERU1 |= ((0x0A) << SRPN);

    SRC_SCUERU1 &= ~((0x3) << TOS);             // CPU0 services

    SRC_SCUERU1 |= (1 << SRE);                  // Service Request is enabled

    //-------------------SRC Interrupt Router 번호 선택 테스트(End)-------------------------------------------------

}

/* Initialize Timer Request Unit (CCU60) */
void init_CCU60(void)
{
    /* CCU60 T12 Setting */
    initaccess_tiSystem();

    CCU60_CLC &= ~(1 << DISR);                  // Enable CCU60 Module

    finishaccess_tiSystem();

    while((CCU60_CLC & (1 << DISS)) != 0);      // Wait until module is enabled

    CCU60_TCTR0 &= ~((0x7) << T12CLK);          // f_T12 = f_CCU6 / prescaler
    CCU60_TCTR0 |= ((0x3) << T12CLK);           // F_CCU6 = 100 MHz, prescaler = 2048
    CCU60_TCTR0 |= (1 << T12PRE);               // f_T12 = 48828Hz

    CCU60_TCTR0 &= ~(1 << CTM);                 // T12 always counts up and continues counting
                                                // from zero after reaching the period value

    //CCU60_TCTR0 |= (1 << CTM);                  // Center aligned Mode----csj. 추가 후 동작 확인

//    CCU60_T12PR = 24414 -1;                     // Interrupt freq. = f_T12 / (period value +1)
//    CCU60_TCTR4 |= (1 << T12STR);               // Interrupt freq. = 2Hz

    CCU60_T12PR = 12207 -1;                     // Interrupt freq. = f_T12 / (period value +1)
    CCU60_TCTR4 |= (1 << T12STR);               // Interrupt freq. = 4Hz

    CCU60_T12 = 0;                              // Clear T12 counting value

    /* CCU60 T12 Interrupt Setting */
    CCU60_INP &= ~((0x3) << INPT12);            // Service Request output SR0 is selected
    CCU60_IEN |= (1 << ENT12PM);                // Enable Interrupt for T12 Period-Match

    /* SRC Interrupt Setting for CCU60 */
    SRC_CCU60_SR0 &= ~((0xFF) << SRPN);         // Set Priority : 0x0B
    SRC_CCU60_SR0 |= ((0x0B) << SRPN);

    SRC_CCU60_SR0 &= ~((0x3) << TOS);           // CPU0 services

    SRC_CCU60_SR0 |= (1 << SRE);                // Service Request is enabled

    /* CCU60 T12 Start */
    //CCU60_TCTR4 |= (1 << T12RS);                // T12 starts counting --> csj. 주석처리 : 아래 switch2의 ISR에 의해 동작하도록 위치 옮겼음

}

/* Initialize Timer Request Unit (CCU60) */
void init_VADC(void)
{
    /* CCU60 T12 Setting */
    initaccess_tiSystem();

    VADC_CLC &= ~(1 << DISR);                  // Enable VACD Module

    finishaccess_tiSystem();

    while((VADC_CLC & (1 << DISS)) != 0);      // Wait until module is enabled

    VADC_G4ARBPR |= ((0x3) << PRIO0);          // Highest Priority for Request Source 0
    VADC_G4ARBPR &= ~(1 << CSM0);              // Conversion Start Mode : Wait for start mode

    VADC_G4ARBPR |= (1 << ASEN0);              // Arbitration Source Input 0 Enable

    VADC_G4QMR0 &= ~((0x3) << ENGT);            // Enable Conversion Requests
    VADC_G4QMR0 |= ((0x1) << ENGT);
    //VADC_G4QMR0 |= ((0x2) << ENGT);

    VADC_G4QMR0 |= (1 << FLUSH);                // Clear all Queue Entries

    VADC_G4ARBCFG |= ((0x3) << ANONC);          // Analog Converter : Normal Operation

    VADC_G4ICLASS0 &= ~((0x7) << CMS);          // Group-specific Class0 (clear and set 동시, b0111)
                                                // Conversion Mode : Standard Conversion (12-bit)
    //VADC_G4ICLASS0 |= ((0x2) << CMS);          // csj..8bit로 set

    // VADC Group 4 Channel 7 Setting
    VADC_G4CHCTR7 |= (1 << RESPOS);             // Read Results Right-aligned
    VADC_G4CHCTR7 &= ~((0xF) << RESREG);        // Store Results in Group Result Register G4RES1
    VADC_G4CHCTR7 |= (1 << RESREG);
    VADC_G4CHCTR7 &= ~((0x3) << ICLSEL);        // Use Group-specific Class0

}

void VADC_startConversion(void)
{
    // No fill and Start Queue
    VADC_G4QINR0 &= ~(0x1F);                    // Request Channel Number :7
    VADC_G4QINR0 |= (0x07);

    VADC_G4QINR0 &= ~(1 << RF);                 // No fill : it is converted once

    VADC_G4QMR0 |= (1 << TREV);                 // Generate a Trigger Event
    //VADC_G4QMR0 &= ~(1 << TREV);                 // Generate a Trigger Event
}

unsigned int VADC_readResult(void)
{
    unsigned int result;

    while((VADC_G4RES1 & (1 << VF)) == 0);      //Wait until New Result Available

    result = (VADC_G4RES1 & ((0xFFFF) << RESULT));  //Read Result

    return result;

}


void init_GTM_TOM0_PWM(void)
{
    // GTM Enable
    initaccess_tiSystem();

    GTM_CLC &= ~(1 << DISR);        // Enable GTM Module

    finishaccess_tiSystem();

    while((GTM_CLC & (1 << DISS)) != 0);    // Wait until module is enabled

    // GTM Clock Setting
    GTM_CMU_FXCLK_CTRL &= ~((0xF) << FXCLK_SEL);    // Input clock of CMU_FXCLK : CMU_GCLK_EN

    GTM_CMU_CLK_EN &= ~((0x3) << EN_FXCLK);         // Enable all CMU_FXCLK
    GTM_CMU_CLK_EN |= ((0x2) << EN_FXCLK);

    // GTM TOM0 PWM Setting
    /*TMO0 채널 1*/
    GTM_TOM0_TGC0_GLB_CTRL &= ~((0x3) << UPEN_CTRL1);   // TOM0 channel 1 enable update of
    GTM_TOM0_TGC0_GLB_CTRL |= ((0x2) << UPEN_CTRL1);    // register CMO0, CM1, CLK_SRC

    GTM_TOM0_TGC0_FUPD_CTRL &= ~((0x3) << FUPD_CTRL1);  // Enable force update of TOM0 channel 1
    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << FUPD_CTRL1);
    GTM_TOM0_TGC0_FUPD_CTRL &= ~((0x3) << RSTCN0_CH1);  // Reset CN0 of TOM0 channel 1 on force update
    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << RSTCN0_CH1);

    GTM_TOM0_TGC0_ENDIS_CTRL &= ~((0x3) << ENDIS_CTRL1);  // Enable channel 1 on an update trigger
    GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2) << ENDIS_CTRL1);
    GTM_TOM0_TGC0_OUTEN_CTRL &= ~((0x3) << OUTEN_CTRL1);  // Enable channel 1 output on an update trigger
    GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2) << OUTEN_CTRL1);

    GTM_TOM0_CH1_CTRL |= (1 << SL);                       // High signal level for duty cycle

    GTM_TOM0_CH1_CTRL &= ~((0x7) << CLK_SRC_SR);            // Clock source : CMU_FXCLK(1) = 6250 kHz (100MHz / 16분주 = 6250kHz)
    GTM_TOM0_CH1_CTRL |= (1 << CLK_SRC_SR);
    GTM_TOM0_CH1_SR0 = 12500 - 1;                           // PWM freq = 6250 kHz /12500 = 500Hz
    //GTM_TOM0_CH1_SR1 = 0;                                   // Duty cycle = 0
    //GTM_TOM0_CH1_SR1 = 1250 - 1;                              // Duty cycle = 10
    //GTM_TOM0_CH1_SR1 = 2500 - 1;                              // Duty cycle = 20
    //GTM_TOM0_CH1_SR1 = 6250 - 1;                            // Duty cycle = 50
    //GTM_TOM0_CH1_SR1 = 12500 - 1;                           // Duty cycle = 100

    GTM_TOUTSEL6 &= ~((0x3) << SEL7);                       // TOUT103 : TOM0 channel 1


    /*TMO0 채널2*/
    GTM_TOM0_TGC0_GLB_CTRL &= ~((0x3) << UPEN_CTRL2);   // TOM0 channel 2 enable update of
    GTM_TOM0_TGC0_GLB_CTRL |= ((0x2) << UPEN_CTRL2);    // register CMO0, CM1, CLK_SRC

    GTM_TOM0_TGC0_FUPD_CTRL &= ~((0x3) << FUPD_CTRL2);  // Enable force update of TOM0 channel 2
    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << FUPD_CTRL2);
    GTM_TOM0_TGC0_FUPD_CTRL &= ~((0x3) << RSTCN0_CH2);  // Reset CN0 of TOM0 channel 2 on force update
    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << RSTCN0_CH2);

    GTM_TOM0_TGC0_ENDIS_CTRL &= ~((0x3) << ENDIS_CTRL2);  // Enable channel 2 on an update trigger
    GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2) << ENDIS_CTRL2);
    GTM_TOM0_TGC0_OUTEN_CTRL &= ~((0x3) << OUTEN_CTRL2);  // Enable channel 2 output on an update trigger
    GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2) << OUTEN_CTRL2);

    GTM_TOM0_CH2_CTRL |= (1 << SL);                       // High signal level for duty cycle

    GTM_TOM0_CH2_CTRL &= ~((0x7) << CLK_SRC_SR);            // Clock source : CMU_FXCLK(2) = 6250 kHz (100MHz / 16분주 = 6250kHz)
    GTM_TOM0_CH2_CTRL |= (1 << CLK_SRC_SR);
    GTM_TOM0_CH2_SR0 = 12500 - 1;                           // PWM freq = 6250 kHz /12500 = 500Hz
    //GTM_TOM0_CH2_SR1 = 1250 - 1;                          // Duty cycle = 10

    GTM_TOUTSEL6 &= ~((0x3) << SEL8);                       // TOUT104 : TOM0 channel 3

    /*TOM0_CH1, CH2 트리거 */
    GTM_TOM0_TGC0_GLB_CTRL |= (1 << HOST_TRIG);             // Trigger request signal to update

    /*TMO 채널11*/
    GTM_TOM0_TGC1_GLB_CTRL &= ~((0x3) << UPEN_CTRL3);   // TOM0 channel 11 enable update of
    GTM_TOM0_TGC1_GLB_CTRL |= ((0x2) << UPEN_CTRL3);    // register CM0, CM1, CLK_SRC

    GTM_TOM0_TGC1_FUPD_CTRL &= ~((0x3) << FUPD_CTRL3);  // Enable force update of TOM0 channel 11
    GTM_TOM0_TGC1_FUPD_CTRL |= ((0x2) << FUPD_CTRL3);
    GTM_TOM0_TGC1_FUPD_CTRL &= ~((0x3) << RSTCN0_CH3);  // Reset CN0 of TOM0 channel 11 on force update
    GTM_TOM0_TGC1_FUPD_CTRL |= ((0x2) << RSTCN0_CH3);

    GTM_TOM0_TGC1_ENDIS_CTRL &= ~((0x3) << ENDIS_CTRL3); // Enable channel 11 on an update trigger
    GTM_TOM0_TGC1_ENDIS_CTRL |= ((0x2) << ENDIS_CTRL3);
    GTM_TOM0_TGC1_OUTEN_CTRL &= ~((0x3) << OUTEN_CTRL3); // Enable channel 11 output on an update trigger
    GTM_TOM0_TGC1_OUTEN_CTRL |= ((0x2) << OUTEN_CTRL3);

    GTM_TOM0_CH11_CTRL |= (1 << SL);                    // High signal level for duty cycle

    GTM_TOM0_CH11_CTRL &= ~((0x7) << CLK_SRC_SR);       // Clock source : CMU_FXCLK(1) = 6250 kHz
    GTM_TOM0_CH11_CTRL |= (1 << CLK_SRC_SR);
    GTM_TOM0_CH11_SR0 = 12500 - 1;                      // PWM freq. = 6250 kHz / 12500 = 500 Hz
    GTM_TOM0_CH11_SR1 = 0;                              // Duty cycle = 0

    GTM_TOUTSEL0 &= ~((0x3) << SEL3);                   // TOUT3 : TOM0 channel 11

    GTM_TOM0_TGC1_GLB_CTRL |= (1 << HOST_TRIG);         // Trigger request signal to update


}

#define PWM_FREQ        6250000
int num_tones = 8;
int tones[] = {261, 277, 294, 311, 330, 349, 370, 392};

IfxCpu_syncEvent g_cpuSyncEvent = 0;

int core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    
    //volatile int cycle;//아래와 같이 선언하면 컴파일러 최적화 옵션을 적용할 경우 for 문에서만 사용하기 때문에 최적화 해 버린다.(없앤다.)
                         //최적화하면 설정한 카운터만큼 동작을 안 하고 더 빨라짐
    //int cycle;//LED 토글이 더 빨라짐(vs. volatile 선언 대비 : 이유는 int는 레지스터에서 계속 읽고 쓰고 하지만 volatile은 읽고 쓰고를 RAM에 접근하기 때문에 속도가 느림)

    unsigned int adcResult;
    unsigned int duty;
    //float duty;


    init_RGBLED();      // Initialize PORT
    init_VADC();        // Initialize VADC
    init_LED();         // Initialize LED
    init_Buzzer();      // Initialize Buzzer
    //init_Switch();      // Initialize Switch
    //init_ERU();         // Initialize ERU for switch interrupt
    //init_CCU60();       // Initialize CCU60 for timer interrupt
    init_GTM_TOM0_PWM();

    while(1)
    {
        VADC_startConversion();
        adcResult = VADC_readResult();
        printf("adcResult is 0x%X at 0x%p\n", adcResult, &adcResult);

        //가변 저항 변화에 따른 PWM Duty 조정하는 로직 추가 - RED LED 밝기 조정
        duty = 12500/4096*adcResult;  //adc 값 0~4095를 듀티 0~100%로 매핑한다.
                                      //정수 연산을 위해 듀티 100%일때 12500 구간으로 환산하고 12bit 최대 구간 4096으로 계산(출력은 정수값)
        GTM_TOM0_CH1_SR1 = duty-1;      //duty가 usigned int일때 adc값 0 근처에서 LED가 깜빡임

        GTM_TOM0_CH2_SR1 = 12500 -(duty-1); //ch1 듀티와 반대로 설정


        //GTM_TOM0_CH11_SR1 = duty-1;         //ch11 듀티 for buzzer
        //GTM_TOM0_CH11_SR1 = 0;
        //가변 저항 변화에 따른 RGB LED 제어 로직
        if(adcResult >= /*1000*/3096)
        {
            PORT02_OMR |= (1 << PS7);           //Set LED RED
            PORT10_OMR |= (1 << PCL5);          //Clear LED GREEN
            PORT10_OMR |= (1 << PCL3);          //Clear LED Blue

            GTM_TOM0_CH11_SR0 = 15943;          //ch11 주파수 for buzzer (높은 도음)
            GTM_TOM0_CH11_SR1 = 15943/2;        //ch11 듀티비 for buzzer
        }
        else if(adcResult >= /*800*/2048)
        {
            PORT02_OMR |= (1 << PCL7);          //Clear LED RED
            PORT10_OMR |= (1 << PS5);           //Set LED GREEN
            PORT10_OMR |= (1 << PCL3);          //Clear LED BLUE

            GTM_TOM0_CH11_SR0 = 18939;          //ch11 주파수 for buzzer (솔음)
            GTM_TOM0_CH11_SR1 = 18939/2;        //ch11 듀티비 for buzzer
        }
        else if(adcResult >= /*500*/1024)
        {
            PORT02_OMR |= (1 << PCL7);          //Clear LED RED
            PORT10_OMR |= (1 << PCL5);          //Clear LED GREEN
            PORT10_OMR |= (1 << PS3);           //Set LED BLUE

            GTM_TOM0_CH11_SR0 = 23946;          //ch11 주파수 for buzzer (낮은 도음)
            GTM_TOM0_CH11_SR1 = 23946/2;        //ch11 듀티비 for buzzer
        }
        else
        {
            PORT02_OMR |= (1 << PCL7);          //Clear LED RED
            PORT10_OMR |= (1 << PCL5);          //Clear LED GREEN
            PORT10_OMR |= (1 << PCL3);          //Clear LED BLUE

            GTM_TOM0_CH11_SR0 = 23946;          //ch11 주파수 for buzzer (낮은 도음)
            GTM_TOM0_CH11_SR1 = 0;              //ch11 주파수 for buzzer (무음)
        }

    }
    return (1);
}



// ISR 함수 구현
// switch ISR : 우선 순위 0x0A로 설정

int timerISR_RunSts;

__interrupt(0x0A) __vector_table(0)
void ERU0_ISR(void)
{
    PORT10_OMR |= ((1 << PCL1) | (1 << PS1)); //Toggle LED RED
    if (timerISR_RunSts == 0)
    {
        CCU60_TCTR4 |= (1 << T12RS);             // T12 starts counting
        timerISR_RunSts = 1;
        //VADC_G4QMR0 |= (1 << TREV);
    }
    else
    {
        CCU60_TCTR4 |= (1 << T12RR);
        timerISR_RunSts = 0;                    // T12 stop counting
        PORT10_OMR |= (1 << PCL2);              // timer interrupt가 멈출 때 switch2 interrupt에서 토글 상태인 blue led를 무조건 Off 하는 로직임
        //VADC_G4QMR0 &= ~(1 << TREV);
        //VADC_G4QMR0 |= (1 << 10);
    }

}

// timer ISR : 우선 순위 0x0B이기 때문에 switch ISR보다 우선 순위가 높다.
__interrupt(0x0B) __vector_table(0)
void CCU60_T12_ISR(void)
{
    PORT10_OMR |= ((1 << PCL2) | (1 << PS2)); //Toggle LED Blue

}



//---------------------------- LED 실습 (보관)--------------------------------
//while(1)
//{
//
//    /* Red LED */
///*        if((PORT02_IN & (1 << P1)) == 0) {
//        PORT10_OMR |= (1 << PS1);   //LED RED
//    }
//    else {
//        PORT10_OMR |= (1 << PCL1);
//    }
//*/
//    /* Blue LED */
///*        if((PORT02_IN & (1 << P0)) == 0) {
//        PORT10_OMR |= (1 << PS2);   //LED Blue
//    }
//    else {
//        PORT10_OMR |= (1 << PCL2);
//    }
//*/
//    /*
//    PORT10_OMR |= ((1 << PCL1) | (1 << PS1));   //Toggle LED RED
//    for(cycle = 0; cycle < 5000000; cycle++);   //delay
//
//    PORT10_OMR |= ((1 << PCL2) | (1 << PS2));   //Toggle LED BLUE
//    for(cycle = 0; cycle < 5000000; cycle++);   //delay
//    */
//
//}


//---------------------------- ADC 실습 (보관)--------------------------------

//while(1)
//{
//    VADC_startConversion();
//    adcResult = VADC_readResult();
//
//    if(adcResult >= /*1000*/3096)
//    {
//        PORT02_OMR |= (1 << PS7);           //Set LED RED
//        PORT10_OMR |= (1 << PCL5);          //Clear LED GREEN
//        PORT10_OMR |= (1 << PCL3);          //Clear LED Blue
//    }
//    else if(adcResult >= /*800*/2048)
//    {
//        PORT02_OMR |= (1 << PCL7);          //Clear LED RED
//        PORT10_OMR |= (1 << PS5);           //Set LED GREEN
//        PORT10_OMR |= (1 << PCL3);          //Clear LED BLUE
//    }
//    else if(adcResult >= /*500*/1024)
//    {
//        PORT02_OMR |= (1 << PCL7);          //Clear LED RED
//        PORT10_OMR |= (1 << PCL5);          //Clear LED GREEN
//        PORT10_OMR |= (1 << PS3);           //Set LED BLUE
//    }
//    else
//    {
//        PORT02_OMR |= (1 << PCL7);          //Clear LED RED
//        PORT10_OMR |= (1 << PCL5);          //Clear LED GREEN
//        PORT10_OMR |= (1 << PCL3);          //Clear LED BLUE
//    }
//
//}
//return (1);
//}
